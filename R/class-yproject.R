
is_yproj <- function(x) {
  inherits(x, "yproj")
}

##' Load a project-wide spec file
##'
##' @param file file name
##'
##' @examples
##'
##' file <- file_proj_ex()
##'
##' spec <- load_spec_proj(file)
##'
##' spec
##'
##' @export
load_spec_proj <- function(file) {
  
  x <- load_spec_file(file)
  
  meta <- get_meta(x)
  
  path <- meta[["path"]]
  
  defaults <- meta[names(meta) %in% c("data_path")]
  
  # no nulls
  nulls <- map_lgl(x, is.null)
  if(any(nulls)) {
    err <- paste0(names(x)[which(nulls)],collapse = ', ')
    .stop("empty entries in project file\n ", err)
  }
  
  # description is required
  desc <- map_chr(x, "description", .default = '.')
  if(any(desc=='.')) {
    err <- paste0(names(x)[which(is.na(desc))],collapse = ', ')
    .stop("entries in project file with no description\n ", err)
  }
  
  x[] <- imap(x, function(x,y) {
    x <- combine_list(defaults,x)
    
    x[["name"]] <- y
    
    add_path <- FALSE  
    if(.no("spec_path", x)) {
      x[["spec_path"]] <-  path 
      add_path <- TRUE
    } else {
      x[["spec_path"]] <- x[["path"]]  
    }
    if(.no("spec_file", x)) {
      x[["spec_file"]] <- paste0(y, ".yml")
    }
    if(.no("data_file", x)) {
      x[["data_file"]] <- paste0(y, ".xpt")
    }
    if(.no("data_path",x)) {
      x[["data_path"]] <- path
    }
    if(add_path) {
      x[["spec_file"]] <- normalizePath(
        file.path(x[["spec_path"]], x[["spec_file"]]),
        mustWork = FALSE
      )
    }
    x
  })
  structure(x, class = "yproj", meta = meta)
}

##' @export
print.yproj <- function(x,i=0,...) {
  names <- map_chr(x, "name")
  desc <- map_chr(x, "description")
  ans <- data.frame(name = names, description = desc)
  print.data.frame(ans, row.names = FALSE, right = FALSE)
}

##' @export
##' @method as.list yproj
as.list.yproj <- function(x, ...) {
  unclass(x)
}

assemble_proj_info <- function(x) {
  met <- get_meta(x)
  description <- met[["description"]]
  if(is.null(description)) {
    stop("A description must be supplied in the SETUP__ front matter")  
  }
  file <- basename(met[["yml_file"]])
  name <- met[["name"]]
  if(is.null(name)) {
    name <- tools::file_path_sans_ext(file)  
  }
  data_path <- met[["data_path"]]
  if(is.null(data_path)) {
    data_path <- "data/derived"  
  }
  
  spec_path <- met[["spec_path"]]
  if(is.null(spec_path)){
    spec_path <- normalizePath(dirname(file))
  }
  spec_file <- met[["yml_file"]]
  data_file <- met[["data_file"]]
  if(is.null(data_file)) {
    data_file <- paste0(name, ".xpt")  
  }
  ans <- list(
    data_path = data_path, 
    data_file = data_file,
    spec_path = spec_path, 
    spec_file = spec_file,
    description = description, 
    name = name
  )
  ans
}

##' Create a project object from data spec objects
##' 
##' @param ... yspec objects
##' @param output the name and path where the project file is to be written
##' @param sponsor used when rendering the define document
##' @param projectnumber used when rendering the define document
##' @param data_path used when rendering the define document
##' @return an object of class yproj
##' @export
as_proj_spec <- function(..., output=tempfile(fileext="yml"), 
                         sponsor="", projectnumber="", data_path = "data/derived") {
  lst <- list(...) 
  proj <- map(lst, assemble_proj_info)
  names(proj) <- map_chr(proj, "name")
  if(any(duplicated(names(proj)))) {
    dups <- names(proj)[duplicated(names(proj))]
    dups <- paste0("  ", dups)
    stop("Duplicated spec names:\n", paste0(dups,collapse = "\n"))
  }
  output <- normalizePath(output,mustWork=FALSE)
  meta <- list(
    sponsor=sponsor, projectnumber=projectnumber, 
    yml_file = output, 
    path = dirname(output), 
    data_path = data_path
  )
  txt <- yaml::as.yaml(c(list(SETUP__ = meta),proj))
  message("Writing project file to:\n ", output)
  writeLines(
    con = output,
    c("# Generated by yspec::as_proj_spec; do not edit by hand", 
      paste0("# ", date()),
      txt)
  )
  structure(proj, meta=meta, class="yproj")
}




